
void	wait_processes(t_exec *exec)
{
	pid_t	wpid;
	int		status;
	int		total_cmd;

   	total_cmd = exec->total_cmd - 1;
	while (total_cmd >= 0)
	{
		wpid = waitpid(exec->pids[total_cmd], &status, 0);
		if (total_cmd == exec->total_cmd - 1)
		{
			if (WIFEXITED(status))
			{
				//printf("adeu\n");
				exec->exit[0] = WEXITSTATUS(status);
			}
			else if (WIFSIGNALED(status))
			{
				//printf("hola\n");
				exec->exit[0] = WTERMSIG(status);
				//printf("exit: %i\n", exec->exit[0]);
			}
		}
		total_cmd--;
	}
	//printf("exit final: %i\n", exec->exit[0]);
	//printf("global var: %i\n", g_exit_sig);
}

/*
launch as many processes as there are command to execute separated
by pipes.
malloc an array of pids. exit if fails
iterate over a loop for the total nber of process. fork() fails quit,
otherwise :
- if child process -> execute the command : we pass the node with data
- if parent : add the pids to array. in the end add the whole array to
exec object.
*/
void	launch_process(t_exec *exec, t_proc **pcs_chain)
{
	int		i;
	pid_t	pid;
	t_proc	*pcs;

	if (!exec || !*pcs_chain)
		return ;
	(exec)->pids = malloc(sizeof(pid_t) * (exec)->total_cmd);
	if (!(exec)->pids)
		error_msg(MALLOC_MESS, ENOMEM, exec, NULL);
	pcs = *pcs_chain;
	i = 0;
	while (i < (exec)->total_cmd)
	{
		pid = fork();
		if (pid == -1)
			error_msg("fork failed", ENOMEM, exec, NULL);
		if (pid == 0)
			command_process(pcs, exec);
		if (pid > 0)
			exec->pids[i] = pid;
		close_cmd_fd(pcs);
		pcs = pcs->next;
		i++;
	}
}
/*
we first check no empty data structure, then traverse to the node
being our execution target.
- if this is the first node and a file descriptor is open (due to a 
< caught during parsing and valid file) : we redirect the stdin
to this fd. if there is a following command, we redirect stdout to 
the corresponding pipe (pipe[1]) -> see for pipe sync. we then close the 
fd.
- if this is the last command (position == nb_cmmd - 1 bcause of array pos):
if there is a fd for output and we redirect out to it. fi there were a cmd
before (and therefore a pipe) - we redirect stdin with it
- if neither first nor last command, it is a middle one and therefore
stdin redirect to read of previous pipe and stdout redirect to write 
of next pipe. arithmetic explained outside of this program
- we then close all pipes to avoid hanging pipes
- execute the command
*/

void exec_handler(int signal, siginfo_t *data, void *n_data)
{
	(void) data;
	(void) n_data;
	write(1, "OOOOOOOO\n", 10);
 	if (signal == SIGINT)
	{
		write(1, "OOOOOOOO\n\n", 10);
		g_exit_sig = 130;



	}
	else if (signal == SIGQUIT)
	{
		//g_exit_sig = 131;
		ft_printf("Quit: 3\n\n");
		ft_printf("\n");

	}
}

void	command_process(t_proc *pcs, t_exec *exec)
{
	struct sigaction    sign;
	//init_signals(EXEC, exec);
	printf("hola\n\n\n");
	sign.sa_flags = SA_RESTART;
	sigemptyset(&sign.sa_mask);
	sign.sa_sigaction = exec_handler;
	sigaction(SIGINT, &sign, NULL);
	sigaction(SIGQUIT, &sign, NULL);

	if (!pcs)
		return ;
	if (pcs->fd[0] == -1 || pcs->fd[1] == -1)
		error_msg(BADF_MESS, EBADF, exec, pcs);
	io_redirect(pcs, exec);
	close_all_pipes(exec);
	if (is_builtin(pcs))
		exec_builtin(pcs, exec);
	build_execve(&pcs, &exec);
	error_msg("execve failure", 1, exec, pcs);
}